import{p as n}from"./matrix-sdk-crypto-wasm-COx1Ym5k.js";import{l as g,K as x,L as ge,b as K,D as F,E as S,H as T,c as f,e as be,d as de,g as G,T as Ke,h as Ie,s as I,j as N,k as le,V as b,m as W,n as ye,o as B,p as m,q as pe,r as fe,u as me,v as y,M as we,w as q,A as Ee,x as Me,U as J,y as j,z as Ce,B as U,S as Z,F as X,G as De,I as ee,J as _e,N as Be,O as H,P as te,Q as v,R as k,W as A,X as D,Y as O,Z as R,$ as qe}from"./index-CLDJFe_s.js";class Oe{constructor(e,t,s,i,r){this.olmMachine=e,this.keyClaimManager=t,this.outgoingRequestManager=s,this.room=i,this.encryptionSettings=r,this.lazyLoadedMembersResolved=!1,this.currentEncryptionPromise=Promise.resolve(),this.prefixedLogger=g.getChild(`[${i.roomId} encryption]`);const o=i.getJoinedMembers();this.olmMachine.updateTrackedUsers(o.map(a=>new n.UserId(a.userId))).catch(a=>this.prefixedLogger.error("Error initializing tracked users",a))}onCryptoEvent(e){if(JSON.stringify(this.encryptionSettings)!=JSON.stringify(e))throw new Error("Cannot reconfigure an active RoomEncryptor")}onRoomMembership(e){(e.membership==x.Join||e.membership==x.Invite&&this.room.shouldEncryptForInvitedMembers())&&this.olmMachine.updateTrackedUsers([new n.UserId(e.userId)]).catch(t=>{this.prefixedLogger.error("Unable to update tracked users",t)})}async prepareForEncryption(e,t){await this.encryptEvent(null,e,t)}encryptEvent(e,t,s){const i=new ge(this.prefixedLogger,e?e.getTxnId()??"":"prepareForEncryption"),r=this.currentEncryptionPromise.catch(()=>{}).then(async()=>{await K(i,"ensureEncryptionSession",async()=>{await this.ensureEncryptionSession(i,t,s)}),e&&await K(i,"encryptEventInner",async()=>{await this.encryptEventInner(i,e)})});return this.currentEncryptionPromise=r,r}async ensureEncryptionSession(e,t,s){if(this.encryptionSettings.algorithm!=="m.megolm.v1.aes-sha2")throw new Error(`Cannot encrypt in ${this.room.roomId} for unsupported algorithm '${this.encryptionSettings.algorithm}'`);e.debug("Starting encryption");const i=await this.room.getEncryptionTargetMembers();this.lazyLoadedMembersResolved?(e.debug("Processing outgoing requests in background"),this.outgoingRequestManager.doProcessOutgoingRequests()):(await K(this.prefixedLogger,"loadMembersIfNeeded: updateTrackedUsers",async()=>{await this.olmMachine.updateTrackedUsers(i.map(a=>new n.UserId(a.userId)))}),e.debug("Updated tracked users"),this.lazyLoadedMembersResolved=!0,e.debug("Processing outgoing requests"),await K(this.prefixedLogger,"doProcessOutgoingRequests",async()=>{await this.outgoingRequestManager.doProcessOutgoingRequests()})),e.debug(`Encrypting for users (shouldEncryptForInvitedMembers: ${this.room.shouldEncryptForInvitedMembers()}):`,i.map(a=>`${a.userId} (${a.membership})`));const r=i.map(a=>new n.UserId(a.userId));await K(this.prefixedLogger,"ensureSessionsForUsers",async()=>{await this.keyClaimManager.ensureSessionsForUsers(e,r)});const o=new n.EncryptionSettings;switch(o.historyVisibility=Te(this.room.getHistoryVisibility()),o.algorithm=n.EncryptionAlgorithm.MegolmV1AesSha2,typeof this.encryptionSettings.rotation_period_ms=="number"&&(o.rotationPeriod=BigInt(this.encryptionSettings.rotation_period_ms*1e3)),typeof this.encryptionSettings.rotation_period_msgs=="number"&&(o.rotationPeriodMessages=BigInt(this.encryptionSettings.rotation_period_msgs)),s.kind){case F.AllDevicesIsolationMode:{const a=this.room.getBlacklistUnverifiedDevices()??t;o.sharingStrategy=n.CollectStrategy.deviceBasedStrategy(a,s.errorOnVerifiedUserProblems)}break;case F.OnlySignedDevicesIsolationMode:o.sharingStrategy=n.CollectStrategy.identityBasedStrategy();break}await K(this.prefixedLogger,"shareRoomKey",async()=>{const a=await this.olmMachine.shareRoomKey(new n.RoomId(this.room.roomId),r,o);if(a)for(const u of a)await this.outgoingRequestManager.outgoingRequestProcessor.makeOutgoingRequest(u)})}async forceDiscardSession(){await this.olmMachine.invalidateGroupSession(new n.RoomId(this.room.roomId))&&this.prefixedLogger.info("Discarded existing group session")}async encryptEventInner(e,t){e.debug("Encrypting actual message content");const s=await this.olmMachine.encryptRoomEvent(new n.RoomId(this.room.roomId),t.getType(),JSON.stringify(t.getContent()));t.makeEncrypted(S.RoomMessageEncrypted,JSON.parse(s),this.olmMachine.identityKeys.curve25519.toBase64(),this.olmMachine.identityKeys.ed25519.toBase64()),e.debug("Encrypted event successfully")}}function Te(c){switch(c){case T.Invited:return n.HistoryVisibility.Invited;case T.Joined:return n.HistoryVisibility.Joined;case T.Shared:return n.HistoryVisibility.Shared;case T.WorldReadable:return n.HistoryVisibility.WorldReadable}}const L="/_matrix/client/unstable/org.matrix.msc3814.v1",Q="org.matrix.msc3814",Ue=7*24*60*60*1e3;class Pe{constructor(e,t,s,i,r){this.logger=e,this.olmMachine=t,this.http=s,this.outgoingRequestProcessor=i,this.secretStorage=r}async isSupported(){try{await this.http.authedRequest(f.Get,"/dehydrated_device",void 0,void 0,{prefix:L})}catch(e){const t=e;if(t.errcode==="M_UNRECOGNIZED")return!1;if(t.errcode==="M_NOT_FOUND")return!0;throw e}return!0}async start(e){this.stop();try{await this.rehydrateDeviceIfAvailable()}catch(t){this.logger.info("dehydration: Error rehydrating device:",t)}e&&await this.resetKey(),await this.scheduleDeviceDehydration()}async isKeyStored(){return!!await this.secretStorage.isStored(Q)}async resetKey(){const e=new Uint8Array(32);globalThis.crypto.getRandomValues(e),await this.secretStorage.store(Q,be(e)),this.key=e}async getKey(e){if(this.key===void 0){const t=await this.secretStorage.get(Q);if(t===void 0){if(!e)return null;await this.resetKey()}else this.key=de(t)}return this.key}async rehydrateDeviceIfAvailable(){const e=await this.getKey(!1);if(!e)return!1;let t;try{t=await this.http.authedRequest(f.Get,"/dehydrated_device",void 0,void 0,{prefix:L})}catch(u){const h=u;if(h.errcode==="M_NOT_FOUND"||h.errcode==="M_UNRECOGNIZED")return this.logger.info("dehydration: No dehydrated device"),!1;throw h}this.logger.info("dehydration: dehydrated device found");const s=await this.olmMachine.dehydratedDevices().rehydrate(e,new n.DeviceId(t.device_id),JSON.stringify(t.device_data));this.logger.info("dehydration: device rehydrated");let i,r=0,o=0;const a=G("/dehydrated_device/$device_id/events",{$device_id:t.device_id});for(;;){const u=await this.http.authedRequest(f.Post,a,void 0,i?{next_batch:i}:{},{prefix:L});if(u.events.length===0)break;r+=u.events.length,i=u.next_batch;const h=await s.receiveEvents(JSON.stringify(u.events));o+=h.length}return this.logger.info(`dehydration: received ${o} room keys from ${r} to-device events`),!0}async createAndUploadDehydratedDevice(){const e=await this.getKey(!0),s=await(await this.olmMachine.dehydratedDevices().create()).keysForUpload("Dehydrated device",e);await this.outgoingRequestProcessor.makeOutgoingRequest(s),this.logger.info("dehydration: uploaded device")}async scheduleDeviceDehydration(){this.stop(),await this.createAndUploadDehydratedDevice(),this.intervalId=setInterval(()=>{this.createAndUploadDehydratedDevice().catch(e=>{this.logger.error("Error creating dehydrated device:",e)})},Ue)}stop(){this.intervalId&&(clearInterval(this.intervalId),this.intervalId=void 0)}}class Ve{constructor(e,t){this.olmMachine=e,this.http=t}async makeOutgoingRequest(e,t){let s;if(e instanceof n.KeysUploadRequest)s=await this.requestWithRetry(f.Post,"/_matrix/client/v3/keys/upload",{},e.body);else if(e instanceof n.KeysQueryRequest)s=await this.requestWithRetry(f.Post,"/_matrix/client/v3/keys/query",{},e.body);else if(e instanceof n.KeysClaimRequest)s=await this.requestWithRetry(f.Post,"/_matrix/client/v3/keys/claim",{},e.body);else if(e instanceof n.SignatureUploadRequest)s=await this.requestWithRetry(f.Post,"/_matrix/client/v3/keys/signatures/upload",{},e.body);else if(e instanceof n.KeysBackupRequest)s=await this.requestWithRetry(f.Put,"/_matrix/client/v3/room_keys/keys",{version:e.version},e.body);else if(e instanceof n.ToDeviceRequest)s=await this.sendToDeviceRequest(e);else if(e instanceof n.RoomMessageRequest){const i=`/_matrix/client/v3/rooms/${encodeURIComponent(e.room_id)}/send/${encodeURIComponent(e.event_type)}/${encodeURIComponent(e.txn_id)}`;s=await this.requestWithRetry(f.Put,i,{},e.body)}else if(e instanceof n.UploadSigningKeysRequest){await this.makeRequestWithUIA(f.Post,"/_matrix/client/v3/keys/device_signing/upload",{},e.body,t);return}else if(e instanceof n.PutDehydratedDeviceRequest){const i=L+"/dehydrated_device";await this.rawJsonRequest(f.Put,i,{},e.body);return}else g.warn("Unsupported outgoing message",Object.getPrototypeOf(e)),s="";if(e.id)try{await K(g,`Mark Request as sent ${e.type}`,async()=>{await this.olmMachine.markRequestAsSent(e.id,e.type,s)})}catch(i){if(i instanceof Error&&(i.message==="Attempt to use a moved value"||i.message==="null pointer passed to rust"))g.log(`Ignoring error '${i.message}': client is likely shutting down`);else throw i}else g.trace(`Outgoing request type:${e.type} does not have an ID`)}async sendToDeviceRequest(e){const t=JSON.parse(e.body),s=[];for(const[r,o]of Object.entries(t.messages))for(const[a,u]of Object.entries(o))s.push(`${r}/${a} (msgid ${u[Ke]})`);g.info(`Sending batch of to-device messages. type=${e.event_type} txnid=${e.txn_id}`,s);const i=`/_matrix/client/v3/sendToDevice/${encodeURIComponent(e.event_type)}/`+encodeURIComponent(e.txn_id);return await this.requestWithRetry(f.Put,i,{},e.body)}async makeRequestWithUIA(e,t,s,i,r){if(!r)return await this.requestWithRetry(e,t,s,i);const o=JSON.parse(i),u=await r(async h=>{const d={...o};h!==null&&(d.auth=h);const l=await this.requestWithRetry(e,t,s,JSON.stringify(d));return JSON.parse(l)});return JSON.stringify(u)}async requestWithRetry(e,t,s,i){let r=0;for(;;)try{return await this.rawJsonRequest(e,t,s,i)}catch(o){r++;const a=Ie(o,r,!0);if(a<0)throw o;await I(a)}}async rawJsonRequest(e,t,s,i){const r={json:!1,headers:{"Content-Type":"application/json",Accept:"application/json"},prefix:""};return await this.http.authedRequest(e,t,s,i,r)}}class Ne{constructor(e,t){this.olmMachine=e,this.outgoingRequestProcessor=t,this.stopped=!1,this.currentClaimPromise=Promise.resolve()}stop(){this.stopped=!0}ensureSessionsForUsers(e,t){const s=this.currentClaimPromise.catch(()=>{}).then(()=>this.ensureSessionsForUsersInner(e,t));return this.currentClaimPromise=s,s}async ensureSessionsForUsersInner(e,t){if(this.stopped)throw new Error("Cannot ensure Olm sessions: shutting down");e.info("Checking for missing Olm sessions");const s=await this.olmMachine.getMissingSessions(t.map(i=>i.clone()));s&&(e.info("Making /keys/claim request"),await this.outgoingRequestProcessor.makeOutgoingRequest(s)),e.info("Olm sessions prepared")}}function Ae(c,e){const t=new Map;for(const[u,h]of c.keys.entries())t.set(u.toString(),h.toBase64());let s=N.Unverified;c.isBlacklisted()?s=N.Blocked:c.isVerified()&&(s=N.Verified);const i=new Map,r=c.signatures.get(e);if(r){const u=new Map;for(const[h,d]of r.entries())d.isValid()&&d.signature&&u.set(h,d.signature.toBase64());i.set(e.toString(),u)}const o=c.algorithms,a=new Set;return o.forEach(u=>{switch(u){case n.EncryptionAlgorithm.MegolmV1AesSha2:a.add("m.megolm.v1.aes-sha2");break;case n.EncryptionAlgorithm.OlmV1Curve25519AesSha2:default:a.add("m.olm.v1.curve25519-aes-sha2");break}}),new le({deviceId:c.deviceId.toString(),userId:e.toString(),keys:t,algorithms:Array.from(a),verified:s,signatures:i,displayName:c.displayName,dehydrated:c.isDehydrated})}function Le(c){return new Map(Object.entries(c).map(([e,t])=>[e,$e(t)]))}function $e(c){var i;const e=new Map(Object.entries(c.keys)),t=(i=c.unsigned)==null?void 0:i.device_display_name,s=new Map;if(c.signatures)for(const r in c.signatures)s.set(r,new Map(Object.entries(c.signatures[r])));return new le({deviceId:c.device_id,userId:c.user_id,keys:e,algorithms:c.algorithms,verified:N.Unverified,signatures:s,displayName:t})}class xe{constructor(e,t,s){this.olmMachine=e,this.outgoingRequestProcessor=t,this.secretStorage=s}async bootstrapCrossSigning(e){if(e.setupNewCrossSigning){await this.resetCrossSigning(e.authUploadDeviceSigningKeys);return}const t=await this.olmMachine.crossSigningStatus(),s=await this.secretStorage.get("m.cross_signing.master"),i=await this.secretStorage.get("m.cross_signing.self_signing"),r=await this.secretStorage.get("m.cross_signing.user_signing"),o=!!(s&&i&&r),a=t.hasMaster&&t.hasUserSigning&&t.hasSelfSigning;if(g.log("bootstrapCrossSigning: starting",{setupNewCrossSigning:e.setupNewCrossSigning,olmDeviceHasMaster:t.hasMaster,olmDeviceHasUserSigning:t.hasUserSigning,olmDeviceHasSelfSigning:t.hasSelfSigning,privateKeysInSecretStorage:o}),a)await this.secretStorage.hasKey()?o?g.log("bootstrapCrossSigning: Olm device has private keys and they are saved in secret storage; doing nothing"):(g.log("bootstrapCrossSigning: Olm device has private keys: exporting to secret storage"),await this.exportCrossSigningKeysToStorage()):g.warn("bootstrapCrossSigning: Olm device has private keys, but secret storage is not yet set up; doing nothing for now.");else if(o){g.log("bootstrapCrossSigning: Cross-signing private keys not found locally, but they are available in secret storage, reading storage and caching locally"),await this.olmMachine.importCrossSigningKeys(s,i,r);const u=await this.olmMachine.getDevice(this.olmMachine.userId,this.olmMachine.deviceId);try{const h=await u.verify();await this.outgoingRequestProcessor.makeOutgoingRequest(h)}finally{u.free()}}else g.log("bootstrapCrossSigning: Cross-signing private keys not found locally or in secret storage, creating new keys"),await this.resetCrossSigning(e.authUploadDeviceSigningKeys);g.log("bootstrapCrossSigning: complete")}async resetCrossSigning(e){const t=await this.olmMachine.bootstrapCrossSigning(!0);await this.secretStorage.hasKey()?(g.log("resetCrossSigning: exporting private keys to secret storage"),await this.exportCrossSigningKeysToStorage()):g.warn("resetCrossSigning: Secret storage is not yet set up; not exporting keys to secret storage yet."),g.log("resetCrossSigning: publishing public keys to server");for(const s of[t.uploadKeysRequest,t.uploadSigningKeysRequest,t.uploadSignaturesRequest])s&&await this.outgoingRequestProcessor.makeOutgoingRequest(s,e)}async exportCrossSigningKeysToStorage(){const e=await this.olmMachine.exportCrossSigningKeys();e!=null&&e.masterKey?await this.secretStorage.store("m.cross_signing.master",e.masterKey):g.error("Cannot export MSK to secret storage, private key unknown"),e!=null&&e.self_signing_key?await this.secretStorage.store("m.cross_signing.self_signing",e.self_signing_key):g.error("Cannot export SSK to secret storage, private key unknown"),e!=null&&e.userSigningKey?await this.secretStorage.store("m.cross_signing.user_signing",e.userSigningKey):g.error("Cannot export USK to secret storage, private key unknown")}}async function se(c){return ke(c,["m.cross_signing.master","m.cross_signing.user_signing","m.cross_signing.self_signing"])}async function ke(c,e){const t=await c.getDefaultKeyId();if(!t)return!1;for(const s of e){const i=await c.isStored(s)||{};if(!(t in i))return!1}return!0}class M extends W{constructor(e,t,s,i){super(),this.olmMachine=e,this.inner=t,this.outgoingRequestProcessor=s,this.supportedVerificationMethods=i,this._accepting=!1,this._cancelling=!1,this.reEmitter=new ye(this);const r=new WeakRef(this);t.registerChangesCallback(async()=>{var o;return(o=r.deref())==null?void 0:o.onChange()})}onChange(){const e=this.inner.getVerification();e instanceof n.Sas?this._verifier===void 0||this._verifier instanceof ie?this.setVerifier(new re(e,this,this.outgoingRequestProcessor)):this._verifier instanceof re&&this._verifier.replaceInner(e):e instanceof n.Qr&&this._verifier===void 0&&this.setVerifier(new ie(e,this.outgoingRequestProcessor)),this.emit(B.Change)}setVerifier(e){this._verifier&&this.reEmitter.stopReEmitting(this._verifier,[B.Change]),this._verifier=e,this.reEmitter.reEmit(this._verifier,[B.Change])}get transactionId(){return this.inner.flowId}get roomId(){var e;return(e=this.inner.roomId)==null?void 0:e.toString()}get initiatedByMe(){return this.inner.weStarted()}get otherUserId(){return this.inner.otherUserId.toString()}get otherDeviceId(){var e;return(e=this.inner.otherDeviceId)==null?void 0:e.toString()}async getOtherDevice(){const e=this.inner.otherDeviceId;if(e)return await this.olmMachine.getDevice(this.inner.otherUserId,e,5)}get isSelfVerification(){return this.inner.isSelfVerification()}get phase(){const e=this.inner.phase();switch(e){case n.VerificationRequestPhase.Created:case n.VerificationRequestPhase.Requested:return m.Requested;case n.VerificationRequestPhase.Ready:return this._accepting?m.Requested:m.Ready;case n.VerificationRequestPhase.Transitioned:if(!this._verifier)throw new Error("VerificationRequest: inner phase == Transitioned but no verifier!");return this._verifier.verificationPhase;case n.VerificationRequestPhase.Done:return m.Done;case n.VerificationRequestPhase.Cancelled:return m.Cancelled}throw new Error(`Unknown verification phase ${e}`)}get pending(){if(this.inner.isPassive())return!1;const e=this.phase;return e!==m.Done&&e!==m.Cancelled}get accepting(){return this._accepting}get declining(){return this._cancelling}get timeout(){return this.inner.timeRemainingMillis()}get methods(){throw new Error("not implemented")}get chosenMethod(){if(this.phase!==m.Started)return null;const e=this.inner.getVerification();return e instanceof n.Sas?b.Sas:e instanceof n.Qr?b.Reciprocate:null}otherPartySupportsMethod(e){const t=this.inner.theirSupportedMethods;if(t===void 0)return!1;const s=Se[e];return t.some(i=>i===s)}async accept(){if(this.inner.phase()!==n.VerificationRequestPhase.Requested||this._accepting)throw new Error(`Cannot accept a verification request in phase ${this.phase}`);this._accepting=!0;try{const e=this.inner.acceptWithMethods(this.supportedVerificationMethods.map($));e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e)}finally{this._accepting=!1}this.emit(B.Change)}async cancel(e){if(!this._cancelling){this._cancelling=!0;try{const t=this.inner.cancel();t&&await this.outgoingRequestProcessor.makeOutgoingRequest(t)}finally{this._cancelling=!1}}}beginKeyVerification(e,t){throw new Error("not implemented")}async startVerification(e){if(e!==b.Sas)throw new Error(`Unsupported verification method ${e}`);if(!await this.getOtherDevice())throw new Error("startVerification(): other device is unknown");const t=await this.inner.startSas();if(t){const[,s]=t;await this.outgoingRequestProcessor.makeOutgoingRequest(s)}if(!this._verifier)throw new Error("Still no verifier after startSas() call");return this._verifier}async scanQRCode(e){const t=n.QrCodeScan.fromBytes(new Uint8ClampedArray(e)),s=await this.inner.scanQrCode(t);if(!this._verifier)throw new Error("Still no verifier after scanQrCode() call");const i=s.reciprocate();return i&&await this.outgoingRequestProcessor.makeOutgoingRequest(i),this._verifier}get verifier(){return this.phase===m.Started?this._verifier:void 0}getQRCodeBytes(){throw new Error("getQRCodeBytes() unsupported in Rust Crypto; use generateQRCode() instead.")}async generateQRCode(){if(!await this.getOtherDevice())throw new Error("generateQRCode(): other device is unknown");const e=await this.inner.generateQrCode();if(e)return Buffer.from(e.toBytes())}get cancellationCode(){var e;return((e=this.inner.cancelInfo)==null?void 0:e.cancelCode())??null}get cancellingUserId(){const e=this.inner.cancelInfo;if(e)return e.cancelledbyUs()?this.olmMachine.userId.toString():this.inner.otherUserId.toString()}}class ve extends W{constructor(e,t){super(),this.inner=e,this.outgoingRequestProcessor=t,this.completionDeferred=fe();const s=new WeakRef(this);e.registerChangesCallback(async()=>{var i;return(i=s.deref())==null?void 0:i.onChange()}),this.completionDeferred.promise.catch(()=>null)}onChange(){if(this.inner.isDone())this.completionDeferred.resolve(void 0);else if(this.inner.isCancelled()){const e=this.inner.cancelInfo();this.completionDeferred.reject(new Error(`Verification cancelled by ${e.cancelledbyUs()?"us":"them"} with code ${e.cancelCode()}: ${e.reason()}`))}this.emit(B.Change)}get hasBeenCancelled(){return this.inner.isCancelled()}get userId(){return this.inner.otherUserId.toString()}cancel(e){const t=this.inner.cancel();t&&this.outgoingRequestProcessor.makeOutgoingRequest(t)}getShowSasCallbacks(){return null}getReciprocateQrCodeCallbacks(){return null}}class ie extends ve{constructor(e,t){super(e,t),this.callbacks=null}onChange(){this.callbacks===null&&this.inner.hasBeenScanned()&&(this.callbacks={confirm:()=>{this.confirmScanning()},cancel:()=>this.cancel()}),super.onChange()}async verify(){this.callbacks!==null&&this.emit(pe.ShowReciprocateQr,this.callbacks),await this.completionDeferred.promise}get verificationPhase(){switch(this.inner.state()){case n.QrState.Created:return m.Ready;case n.QrState.Scanned:return m.Started;case n.QrState.Confirmed:return m.Started;case n.QrState.Reciprocated:return m.Started;case n.QrState.Done:return m.Done;case n.QrState.Cancelled:return m.Cancelled;default:throw new Error(`Unknown qr code state ${this.inner.state()}`)}}getReciprocateQrCodeCallbacks(){return this.callbacks}async confirmScanning(){const e=this.inner.confirmScanning();e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e)}}class re extends ve{constructor(e,t,s){super(e,s),this.callbacks=null}async verify(){await this.sendAccept(),await this.completionDeferred.promise}async sendAccept(){const e=this.inner.accept();e&&await this.outgoingRequestProcessor.makeOutgoingRequest(e)}onChange(){if(super.onChange(),this.callbacks===null){const e=this.inner.emoji(),t=this.inner.decimals();if(e===void 0&&t===void 0)return;const s={};e&&(s.emoji=e.map(i=>[i.symbol,i.description])),t&&(s.decimal=[t[0],t[1],t[2]]),this.callbacks={sas:s,confirm:async()=>{const i=await this.inner.confirm();for(const r of i)await this.outgoingRequestProcessor.makeOutgoingRequest(r)},mismatch:()=>{const i=this.inner.cancelWithCode("m.mismatched_sas");i&&this.outgoingRequestProcessor.makeOutgoingRequest(i)},cancel:()=>{const i=this.inner.cancelWithCode("m.user");i&&this.outgoingRequestProcessor.makeOutgoingRequest(i)}},this.emit(pe.ShowSas,this.callbacks)}}get verificationPhase(){return m.Started}getShowSasCallbacks(){return this.callbacks}replaceInner(e){if(this.inner!=e){this.inner=e;const t=new WeakRef(this);e.registerChangesCallback(async()=>{var s;return(s=t.deref())==null?void 0:s.onChange()}),this.sendAccept(),this.onChange()}}}const Se={[b.Sas]:n.VerificationMethod.SasV1,[b.ScanQrCode]:n.VerificationMethod.QrCodeScanV1,[b.ShowQrCode]:n.VerificationMethod.QrCodeShowV1,[b.Reciprocate]:n.VerificationMethod.ReciprocateV1};function $(c){const e=Se[c];if(e===void 0)throw new Error(`Unknown verification method ${c}`);return e}function Fe(c){switch(c.getType()){case S.KeyVerificationCancel:case S.KeyVerificationDone:case S.KeyVerificationMac:case S.KeyVerificationStart:case S.KeyVerificationKey:case S.KeyVerificationReady:case S.KeyVerificationAccept:return!0;case S.RoomMessage:return c.getContent().msgtype===me.KeyVerificationRequest;default:return!1}}class Ge extends W{constructor(e,t,s){super(),this.olmMachine=e,this.http=t,this.outgoingRequestProcessor=s,this.checkedForBackup=!1,this.serverBackupInfo=void 0,this.activeBackupVersion=null,this.stopped=!1,this.backupKeysLoopRunning=!1,this.keyBackupCheckInProgress=null}stop(){this.stopped=!0}async getActiveBackupVersion(){return await this.olmMachine.isBackupEnabled()?this.activeBackupVersion:null}async getServerBackupInfo(){return await this.checkKeyBackupAndEnable(!1),this.serverBackupInfo}async isKeyBackupTrusted(e){const t=await this.olmMachine.verifyBackup(e),s=await this.olmMachine.getBackupKeys(),i=s==null?void 0:s.decryptionKey;return{matchesDecryptionKey:!!i&&ne(e,i),trusted:t.trusted()}}checkKeyBackupAndEnable(e){return!e&&this.checkedForBackup?Promise.resolve(null):(this.keyBackupCheckInProgress||(this.keyBackupCheckInProgress=this.doCheckKeyBackup().finally(()=>{this.keyBackupCheckInProgress=null})),this.keyBackupCheckInProgress)}async handleBackupSecretReceived(e){var s;const t=await this.checkKeyBackupAndEnable(!0);if(!((s=t==null?void 0:t.backupInfo)!=null&&s.version)||!t.trustInfo.trusted)return g.warn("handleBackupSecretReceived: Received a backup decryption key, but there is no trusted server-side key backup"),!1;try{const i=n.BackupDecryptionKey.fromBase64(e);return ne(t.backupInfo,i)?(g.info("handleBackupSecretReceived: A valid backup decryption key has been received and stored in cache."),await this.saveBackupDecryptionKey(i,t.backupInfo.version),!0):(g.warn("handleBackupSecretReceived: Private decryption key does not match the public key of the current remote backup."),!1)}catch(i){g.warn("handleBackupSecretReceived: Invalid backup decryption key",i)}return!1}async saveBackupDecryptionKey(e,t){await this.olmMachine.saveBackupDecryptionKey(e,t),this.emit(y.KeyBackupDecryptionKeyCached,t)}async importRoomKeys(e,t){await this.importRoomKeysAsJson(JSON.stringify(e),t)}async importRoomKeysAsJson(e,t){await this.olmMachine.importExportedRoomKeys(e,(s,i)=>{var o;const r={total:Number(i),successes:Number(s),stage:"load_keys",failures:0};(o=t==null?void 0:t.progressCallback)==null||o.call(t,r)})}async importBackedUpRoomKeys(e,t,s){const i=new Map;for(const r of e){const o=new n.RoomId(r.room_id);i.has(o)||i.set(o,new Map),i.get(o).set(r.session_id,r)}await this.olmMachine.importBackedUpRoomKeys(i,(r,o,a)=>{var h;const u={total:Number(o),successes:Number(r),stage:"load_keys",failures:Number(a)};(h=s==null?void 0:s.progressCallback)==null||h.call(s,u)},t)}async doCheckKeyBackup(){g.log("Checking key backup status...");let e;try{e=await this.requestKeyBackupVersion()}catch(i){return g.warn("Error checking for active key backup",i),this.serverBackupInfo=void 0,null}this.checkedForBackup=!0,e&&!e.version&&(g.warn("active backup lacks a useful 'version'; ignoring it"),e=void 0),this.serverBackupInfo=e;const t=await this.getActiveBackupVersion();if(!e)return t!==null?(g.log("No key backup present on server: disabling key backup"),await this.disableKeyBackup()):g.log("No key backup present on server: not enabling key backup"),null;const s=await this.isKeyBackupTrusted(e);return s.trusted?t===null?(g.log(`Found usable key backup v${e.version}: enabling key backups`),await this.enableKeyBackup(e)):t!==e.version?(g.log(`On backup version ${t} but found version ${e.version}: switching.`),await this.disableKeyBackup(),await this.enableKeyBackup(e)):g.log(`Backup version ${e.version} still current`):t!==null?(g.log("Key backup present on server but not trusted: disabling key backup"),await this.disableKeyBackup()):g.log("Key backup present on server but not trusted: not enabling key backup"),{backupInfo:e,trustInfo:s}}async enableKeyBackup(e){await this.olmMachine.enableBackupV1(e.auth_data.public_key,e.version),this.activeBackupVersion=e.version,this.emit(y.KeyBackupStatus,!0),this.backupKeysLoop()}async maybeUploadKey(){this.activeBackupVersion!=null&&this.backupKeysLoop()}async disableKeyBackup(){await this.olmMachine.disableBackup(),this.activeBackupVersion=null,this.emit(y.KeyBackupStatus,!1)}async backupKeysLoop(e=1e4){if(this.backupKeysLoopRunning){g.log("Backup loop already running");return}this.backupKeysLoopRunning=!0,g.log(`Backup: Starting keys upload loop for backup version:${this.activeBackupVersion}.`);const t=Math.random()*e;await I(t);try{let s=0,i=null,r=!0;for(;!this.stopped;){let o=null;try{o=await K(g,"BackupRoomKeys: Get keys to backup from rust crypto-sdk",async()=>await this.olmMachine.backupRoomKeys())}catch(a){g.error("Backup: Failed to get keys to backup from rust crypto-sdk",a)}if(!o||this.stopped||!this.activeBackupVersion){g.log(`Backup: Ending loop for version ${this.activeBackupVersion}.`),o||this.emit(y.KeyBackupSessionsRemaining,0);return}try{if(await this.outgoingRequestProcessor.makeOutgoingRequest(o),s=0,this.stopped)break;if(!r&&i===null)try{const a=await this.olmMachine.roomKeyCounts();i=a.total-a.backedUp}catch(a){g.error("Backup: Failed to get key counts from rust crypto-sdk",a)}if(i!==null){this.emit(y.KeyBackupSessionsRemaining,i);const a=this.keysCountInBatch(o);i=Math.max(i-a,0)}}catch(a){if(s++,g.error("Backup: Error processing backup request for rust crypto-sdk",a),a instanceof we){const u=a.data.errcode;if(u=="M_NOT_FOUND"||u=="M_WRONG_ROOM_KEYS_VERSION"){g.log(`Backup: Failed to upload keys to current vesion: ${u}.`);try{await this.disableKeyBackup()}catch(h){g.error("Backup: An error occurred while disabling key backup:",h)}this.emit(y.KeyBackupFailed,a.data.errcode),this.backupKeysLoopRunning=!1,this.checkKeyBackupAndEnable(!0);return}else if(a.isRateLimitError())try{const h=a.getRetryAfterMs();if(h&&h>0){await I(h);continue}}catch(h){g.warn("Backup: An error occurred while retrieving a rate-limit retry delay",h)}}await I(1e3*Math.pow(2,Math.min(s-1,4)))}r=!1}}finally{this.backupKeysLoopRunning=!1}}keysCountInBatch(e){const t=JSON.parse(e.body);return ae(t)}async requestKeyBackupVersion(e){return await Re(this.http,e)}async setupKeyBackup(e){await this.deleteAllKeyBackupVersions();const t=n.BackupDecryptionKey.createRandomKey(),s=t.megolmV1PublicKey,i={public_key:s.publicKeyBase64};await e(i);const r=await this.http.authedRequest(f.Post,"/room_keys/version",void 0,{algorithm:s.algorithm,auth_data:i},{prefix:q.V3});return await this.saveBackupDecryptionKey(t,r.version),{version:r.version,algorithm:s.algorithm,authData:i,decryptionKey:t}}async deleteAllKeyBackupVersions(){var t,s;let e=((t=await this.requestKeyBackupVersion())==null?void 0:t.version)??null;for(;e!=null;)await this.deleteKeyBackupVersion(e),e=((s=await this.requestKeyBackupVersion())==null?void 0:s.version)??null}async deleteKeyBackupVersion(e){g.debug(`deleteKeyBackupVersion v:${e}`);const t=G("/room_keys/version/$version",{$version:e});await this.http.authedRequest(f.Delete,t,void 0,void 0,{prefix:q.V3})}createBackupDecryptor(e){return new We(e)}async restoreKeyBackup(e,t,s){var r;const i=await this.downloadKeyBackup(e);return(r=s==null?void 0:s.progressCallback)==null||r.call(s,{stage:"load_keys"}),this.importKeyBackup(i,e,t,s)}downloadKeyBackup(e){return this.http.authedRequest(f.Get,"/room_keys/keys",{version:e},void 0,{prefix:q.V3})}async importKeyBackup(e,t,s,i){const o=ae(e);let a=0,u=0;const h=async p=>{var C;const w=[];for(const E of p.keys())(await s.decryptSessions(p.get(E))).forEach(z=>{z.room_id=E,w.push(z)});try{await this.importBackedUpRoomKeys(w,t),a+=w.length}catch(E){u+=w.length,g.error("Error importing keys from backup",E)}(C=i==null?void 0:i.progressCallback)==null||C.call(i,{total:o,successes:a,stage:"load_keys",failures:u})};let d=0,l=new Map;for(const[p,w]of Object.entries(e.rooms))if(w.sessions){l.set(p,{});for(const[C,E]of Object.entries(w.sessions)){const Y=l.get(p);Y[C]=E,d+=1,d>=200&&(await h(l),l=new Map,l.set(p,{}),d=0)}}return d>0&&await h(l),{total:o,imported:a}}}function ne(c,e){var t;return c.algorithm!=="m.megolm_backup.v1.curve25519-aes-sha2"?(g.warn("backupMatchesPrivateKey: Unsupported backup algorithm",c.algorithm),!1):((t=c.auth_data)==null?void 0:t.public_key)===e.megolmV1PublicKey.publicKeyBase64}class We{constructor(e){this.decryptionKey=e,this.sourceTrusted=!1}async decryptSessions(e){const t=[];for(const[s,i]of Object.entries(e))try{const r=JSON.parse(this.decryptionKey.decryptV1(i.session_data.ephemeral,i.session_data.mac,i.session_data.ciphertext));r.session_id=s,t.push(r)}catch(r){g.log("Failed to decrypt megolm session from backup",r,i)}return t}free(){this.decryptionKey.free()}}async function Re(c,e){try{const t=e?G("/room_keys/version/$version",{$version:e}):"/room_keys/version";return await c.authedRequest(f.Get,t,void 0,void 0,{prefix:q.V3})}catch(t){if(t.errcode==="M_NOT_FOUND")return null;throw t}}function oe(c,e){return e.auth_data.public_key===c.megolmV1PublicKey.publicKeyBase64}function ae(c){let e=0;for(const{sessions:t}of Object.values(c.rooms))e+=Object.keys(t).length;return e}class Je{constructor(e,t,s){this.logger=e,this.olmMachine=t,this.outgoingRequestProcessor=s,this.stopped=!1,this.outgoingRequestLoopRunning=!1}stop(){this.stopped=!0}doProcessOutgoingRequests(){this.nextLoopDeferred||(this.nextLoopDeferred=fe());const e=this.nextLoopDeferred.promise;return this.outgoingRequestLoopRunning||this.outgoingRequestLoop().catch(t=>{this.logger.error("Uncaught error in outgoing request loop",t)}),e}async outgoingRequestLoop(){if(this.outgoingRequestLoopRunning)throw new Error("Cannot run two outgoing request loops");this.outgoingRequestLoopRunning=!0;try{for(;!this.stopped&&this.nextLoopDeferred;){const e=this.nextLoopDeferred;this.nextLoopDeferred=void 0,await this.processOutgoingRequests().then(e.resolve,e.reject)}}finally{this.outgoingRequestLoopRunning=!1}this.nextLoopDeferred&&this.nextLoopDeferred.reject(new Error("OutgoingRequestsManager was stopped"))}async processOutgoingRequests(){if(this.stopped)return;const e=await this.olmMachine.outgoingRequests();for(const t of e){if(this.stopped)return;try{await K(this.logger,`Make outgoing request ${t.type}`,async()=>{await this.outgoingRequestProcessor.makeOutgoingRequest(t)})}catch(s){this.logger.error(`Failed to process outgoing request ${t.type}: ${s}`)}}}}const P=5e3;class _ extends Error{constructor(e){super(`Failed to get key from backup: ${e}`),this.code=e,this.name="KeyDownloadError"}}class ce extends Error{constructor(e){super("Failed to get key from backup: rate limited"),this.retryMillis=e,this.name="KeyDownloadRateLimitError"}}class He{constructor(e,t,s,i){this.olmMachine=t,this.http=s,this.backupManager=i,this.stopped=!1,this.configuration=null,this.sessionLastCheckAttemptedTime=new Map,this.downloadLoopRunning=!1,this.queuedRequests=[],this.hasConfigurationProblem=!1,this.currentBackupVersionCheck=null,this.onBackupStatusChanged=()=>{this.hasConfigurationProblem=!1,this.configuration=null,this.getOrCreateBackupConfiguration().then(r=>{r&&this.downloadKeysLoop()})},this.logger=e.getChild("[PerSessionKeyBackupDownloader]"),i.on(y.KeyBackupStatus,this.onBackupStatusChanged),i.on(y.KeyBackupFailed,this.onBackupStatusChanged),i.on(y.KeyBackupDecryptionKeyCached,this.onBackupStatusChanged)}isKeyBackupDownloadConfigured(){return this.configuration!==null}async getServerBackupInfo(){return await this.backupManager.getServerBackupInfo()}onDecryptionKeyMissingError(e,t){if(this.isAlreadyInQueue(e,t)){this.logger.trace(`Not checking key backup for session ${t} as it is already queued`);return}if(this.wasRequestedRecently(t)){this.logger.trace(`Not checking key backup for session ${t} as it was already requested recently`);return}this.queuedRequests.push({roomId:e,megolmSessionId:t}),this.downloadKeysLoop()}stop(){this.stopped=!0,this.backupManager.off(y.KeyBackupStatus,this.onBackupStatusChanged),this.backupManager.off(y.KeyBackupFailed,this.onBackupStatusChanged),this.backupManager.off(y.KeyBackupDecryptionKeyCached,this.onBackupStatusChanged)}isAlreadyInQueue(e,t){return this.queuedRequests.some(s=>s.roomId==e&&s.megolmSessionId==t)}markAsNotFoundInBackup(e){const t=Date.now();this.sessionLastCheckAttemptedTime.set(e,t),this.sessionLastCheckAttemptedTime.size>100&&(this.sessionLastCheckAttemptedTime=new Map(Array.from(this.sessionLastCheckAttemptedTime).filter((s,i)=>Math.max(t-i,0)<P)))}wasRequestedRecently(e){const t=this.sessionLastCheckAttemptedTime.get(e);return t?Math.max(Date.now()-t,0)<P:!1}async getBackupDecryptionKey(){try{return await this.olmMachine.getBackupKeys()}catch{return null}}async requestRoomKeyFromBackup(e,t,s){const i=G("/room_keys/keys/$roomId/$sessionId",{$roomId:t,$sessionId:s});return await this.http.authedRequest(f.Get,i,{version:e},void 0,{prefix:q.V3})}async downloadKeysLoop(){if(!this.downloadLoopRunning&&!this.hasConfigurationProblem){this.downloadLoopRunning=!0;try{for(;this.queuedRequests.length>0;){const e=this.queuedRequests[0];try{const t=await this.getOrCreateBackupConfiguration();if(!t){this.downloadLoopRunning=!1;return}const s=await this.queryKeyBackup(e.roomId,e.megolmSessionId,t);if(this.stopped)return;try{await this.decryptAndImport(e,s,t)}catch(i){this.logger.error(`Error while decrypting and importing key backup for session ${e.megolmSessionId}`,i)}this.queuedRequests.shift()}catch(t){if(t instanceof _)switch(t.code){case"MISSING_DECRYPTION_KEY":this.markAsNotFoundInBackup(e.megolmSessionId),this.queuedRequests.shift();break;case"NETWORK_ERROR":await I(P);break;case"STOPPED":this.downloadLoopRunning=!1;return}else t instanceof ce&&await I(t.retryMillis)}}}finally{this.downloadLoopRunning=!1}}}async queryKeyBackup(e,t,s){if(this.logger.debug(`Checking key backup for session ${t}`),this.stopped)throw new _("STOPPED");try{const i=await this.requestRoomKeyFromBackup(s.backupVersion,e,t);return this.logger.debug(`Got key from backup for sessionId:${t}`),i}catch(i){if(this.stopped)throw new _("STOPPED");if(this.logger.info(`No luck requesting key backup for session ${t}: ${i}`),i instanceof we){if(i.data.errcode=="M_NOT_FOUND")throw new _("MISSING_DECRYPTION_KEY");if(i.isRateLimitError()){let o;try{o=i.getRetryAfterMs()??void 0}catch(a){this.logger.warn("Error while retrieving a rate-limit retry delay",a)}throw o&&o>0&&this.logger.info(`Rate limited by server, waiting ${o}ms`),new ce(o??P)}}throw new _("NETWORK_ERROR")}}async decryptAndImport(e,t,s){const i={[e.megolmSessionId]:t},r=await s.decryptor.decryptSessions(i);for(const o of r)o.room_id=e.roomId;await this.backupManager.importBackedUpRoomKeys(r,s.backupVersion)}async getOrCreateBackupConfiguration(){if(this.configuration)return this.configuration;if(this.hasConfigurationProblem)return null;if(this.currentBackupVersionCheck!=null)return this.logger.debug("Already checking server version, use current promise"),await this.currentBackupVersionCheck;this.currentBackupVersionCheck=this.internalCheckFromServer();try{return await this.currentBackupVersionCheck}finally{this.currentBackupVersionCheck=null}}async internalCheckFromServer(){let e=null;try{e=await this.backupManager.getServerBackupInfo()}catch(o){return this.logger.debug(`Backup: error while checking server version: ${o}`),this.hasConfigurationProblem=!0,null}if(this.logger.debug(`Got current backup version from server: ${e==null?void 0:e.version}`),(e==null?void 0:e.algorithm)!="m.megolm_backup.v1.curve25519-aes-sha2")return this.logger.info(`Unsupported algorithm ${e==null?void 0:e.algorithm}`),this.hasConfigurationProblem=!0,null;if(!(e!=null&&e.version))return this.logger.info("No current key backup"),this.hasConfigurationProblem=!0,null;const t=await this.backupManager.getActiveBackupVersion();if(t==null||e.version!=t)return this.logger.info(`The current backup version on the server (${e.version}) is not trusted. Version we are currently backing up to: ${t}`),this.hasConfigurationProblem=!0,null;const s=await this.getBackupDecryptionKey();if(!(s!=null&&s.decryptionKey))return this.logger.debug("Not checking key backup for session (no decryption key)"),this.hasConfigurationProblem=!0,null;if(t!=s.backupVersion)return this.logger.debug(`Version for which we have a decryption key (${s.backupVersion}) doesn't match the version we are backing up to (${t})`),this.hasConfigurationProblem=!0,null;if(e.auth_data.public_key!=s.decryptionKey.megolmV1PublicKey.publicKeyBase64)return this.logger.debug("Key backup on server does not match our decryption key"),this.hasConfigurationProblem=!0,null;const r=this.backupManager.createBackupDecryptor(s.decryptionKey);return this.hasConfigurationProblem=!1,this.configuration={decryptor:r,backupVersion:t},this.configuration}}const ue=[b.Sas,b.ScanQrCode,b.ShowQrCode,b.Reciprocate];class Qe extends W{constructor(e,t,s,i,r,o,a){super(),this.logger=e,this.olmMachine=t,this.http=s,this.userId=i,this.secretStorage=o,this.cryptoCallbacks=a,this.RECOVERY_KEY_DERIVATION_ITERATIONS=5e5,this._trustCrossSignedDevices=!0,this.deviceIsolationMode=new Ee(!1),this.stopped=!1,this.roomEncryptors={},this.reemitter=new ye(this),this.globalBlacklistUnverifiedDevices=!1,this._supportedVerificationMethods=ue,this.outgoingRequestProcessor=new Ve(t,s),this.outgoingRequestsManager=new Je(this.logger,t,this.outgoingRequestProcessor),this.keyClaimManager=new Ne(t,this.outgoingRequestProcessor),this.backupManager=new Ge(t,s,this.outgoingRequestProcessor),this.perSessionBackupDownloader=new He(this.logger,this.olmMachine,this.http,this.backupManager),this.dehydratedDeviceManager=new Pe(this.logger,t,s,this.outgoingRequestProcessor,o),this.eventDecryptor=new je(this.logger,t,this.perSessionBackupDownloader),this.reemitter.reEmit(this.backupManager,[y.KeyBackupStatus,y.KeyBackupSessionsRemaining,y.KeyBackupFailed,y.KeyBackupDecryptionKeyCached]),this.crossSigningIdentity=new xe(t,this.outgoingRequestProcessor,o),this.checkKeyBackupAndEnable()}getOlmMachineOrThrow(){if(this.stopped)throw new Me;return this.olmMachine}set globalErrorOnUnknownDevices(e){}get globalErrorOnUnknownDevices(){return!1}stop(){this.stopped||(this.stopped=!0,this.keyClaimManager.stop(),this.backupManager.stop(),this.outgoingRequestsManager.stop(),this.perSessionBackupDownloader.stop(),this.dehydratedDeviceManager.stop(),this.olmMachine.close())}async encryptEvent(e,t){const s=e.getRoomId(),i=this.roomEncryptors[s];if(!i)throw new Error(`Cannot encrypt event in unconfigured room ${s}`);await i.encryptEvent(e,this.globalBlacklistUnverifiedDevices,this.deviceIsolationMode)}async decryptEvent(e){if(!e.getRoomId())throw new Error("to-device event was not decrypted in preprocessToDeviceMessages");return await this.eventDecryptor.attemptEventDecryption(e,this.deviceIsolationMode)}getEventEncryptionInfo(e){const t={};return t.senderKey=e.getSenderKey()??void 0,t.algorithm=e.getWireContent().algorithm,!t.senderKey||!t.algorithm?(t.encrypted=!1,t):(t.encrypted=!0,t.authenticated=!0,t.mismatchedSender=!0,t)}checkUserTrust(e){return new J(!1,!1,!1)}getStoredCrossSigningForUser(e){return null}async checkOwnCrossSigningTrust(){}async getBackupDecryptor(e,t){if(!(t instanceof Uint8Array))throw new Error("getBackupDecryptor: expects Uint8Array");if(e.algorithm!="m.megolm_backup.v1.curve25519-aes-sha2")throw new Error(`getBackupDecryptor: Unsupported algorithm ${e.algorithm}`);const s=n.BackupDecryptionKey.fromBase64(j(t));if(!oe(s,e))throw new Error("getBackupDecryptor: key backup on server does not match the decryption key");return this.backupManager.createBackupDecryptor(s)}async importBackedUpRoomKeys(e,t,s){return await this.backupManager.importBackedUpRoomKeys(e,t,s)}getVersion(){const e=n.getVersions();return`Rust SDK ${e.matrix_sdk_crypto} (${e.git_sha}), Vodozemac ${e.vodozemac}`}setDeviceIsolationMode(e){this.deviceIsolationMode=e}async isEncryptionEnabledInRoom(e){const t=await this.olmMachine.getRoomSettings(new n.RoomId(e));return!!(t!=null&&t.algorithm)}async getOwnDeviceKeys(){const e=this.olmMachine.identityKeys;return{ed25519:e.ed25519.toBase64(),curve25519:e.curve25519.toBase64()}}prepareToEncrypt(e){const t=this.roomEncryptors[e.roomId];t&&t.prepareForEncryption(this.globalBlacklistUnverifiedDevices,this.deviceIsolationMode)}forceDiscardSession(e){var t;return(t=this.roomEncryptors[e])==null?void 0:t.forceDiscardSession()}async exportRoomKeys(){const e=await this.olmMachine.exportRoomKeys(()=>!0);return JSON.parse(e)}async exportRoomKeysAsJson(){return await this.olmMachine.exportRoomKeys(()=>!0)}async importRoomKeys(e,t){return await this.backupManager.importRoomKeys(e,t)}async importRoomKeysAsJson(e,t){return await this.backupManager.importRoomKeysAsJson(e,t)}async userHasCrossSigningKeys(e=this.userId,t=!1){var r;const s=await this.olmMachine.trackedUsers();let i;for(const o of s)if(e===o.toString()){i=o;break}if(i!==void 0){if(e===this.userId){const a=this.olmMachine.queryKeysForUsers([i.clone()]);await this.outgoingRequestProcessor.makeOutgoingRequest(a)}const o=await this.olmMachine.getIdentity(i);return o==null||o.free(),o!==void 0}else if(t){const a=(r=(await this.downloadDeviceList(new Set([e]))).master_keys)==null?void 0:r[e];return a?!!Object.values(a.keys)[0]:!1}else return!1}async getUserDeviceInfo(e,t=!1){const s=new Map,i=await this.getOlmMachineOrThrow().trackedUsers(),r=new Set;i.forEach(a=>r.add(a.toString()));const o=new Set;for(const a of e)r.has(a)?s.set(a,await this.getUserDevices(a)):o.add(a);if(t&&o.size>=1){const a=await this.downloadDeviceList(o);Object.entries(a.device_keys).forEach(([u,h])=>s.set(u,Le(h)))}return s}async getUserDevices(e){const t=new n.UserId(e),s=await this.olmMachine.getUserDevices(t,1);try{const i=s.devices();try{return new Map(i.map(r=>[r.deviceId.toString(),Ae(r,t)]))}finally{i.forEach(r=>r.free())}}finally{s.free()}}async downloadDeviceList(e){const t={device_keys:{}};return e.forEach(s=>t.device_keys[s]=[]),await this.http.authedRequest(f.Post,"/_matrix/client/v3/keys/query",void 0,t,{prefix:""})}getTrustCrossSignedDevices(){return this._trustCrossSignedDevices}setTrustCrossSignedDevices(e){this._trustCrossSignedDevices=e}async setDeviceVerified(e,t,s=!0){const i=await this.olmMachine.getDevice(new n.UserId(e),new n.DeviceId(t));if(!i)throw new Error(`Unknown device ${e}|${t}`);try{await i.setLocalTrust(s?n.LocalTrust.Verified:n.LocalTrust.Unset)}finally{i.free()}}async crossSignDevice(e){const t=await this.olmMachine.getDevice(new n.UserId(this.userId),new n.DeviceId(e));if(!t)throw new Error(`Unknown device ${e}`);try{const s=await t.verify();await this.outgoingRequestProcessor.makeOutgoingRequest(s)}finally{t.free()}}async getDeviceVerificationStatus(e,t){const s=await this.olmMachine.getDevice(new n.UserId(e),new n.DeviceId(t));if(!s)return null;try{return new Ce({signedByOwner:s.isCrossSignedByOwner(),crossSigningVerified:s.isCrossSigningTrusted(),localVerified:s.isLocallyTrusted(),trustCrossSignedDevices:this._trustCrossSignedDevices})}finally{s.free()}}async getUserVerificationStatus(e){const t=await this.getOlmMachineOrThrow().getIdentity(new n.UserId(e));if(t===void 0)return new J(!1,!1,!1);const s=t.isVerified(),i=t.wasPreviouslyVerified(),r=t instanceof n.UserIdentity?t.identityNeedsUserApproval():!1;return t.free(),new J(s,i,!1,r)}async pinCurrentUserIdentity(e){const t=await this.getOlmMachineOrThrow().getIdentity(new n.UserId(e));if(t===void 0)throw new Error("Cannot pin identity of unknown user");if(t instanceof n.OwnUserIdentity)throw new Error("Cannot pin identity of own user");await t.pinCurrentMasterKey()}async isCrossSigningReady(){const{privateKeysInSecretStorage:e,privateKeysCachedLocally:t}=await this.getCrossSigningStatus(),s=!!t.masterKey&&!!t.selfSigningKey&&!!t.userSigningKey,i=await this.getOwnIdentity();return!!(i!=null&&i.isVerified())&&(s||e)}async getCrossSigningKeyId(e=U.Master){const t=await this.olmMachine.getIdentity(new n.UserId(this.userId));if(!t)return null;try{const s=await this.olmMachine.crossSigningStatus();if(!(s.hasMaster&&s.hasUserSigning&&s.hasSelfSigning)||!t.isVerified())return null;let r;switch(e){case U.Master:r=t.masterKey;break;case U.SelfSigning:r=t.selfSigningKey;break;case U.UserSigning:r=t.userSigningKey;break;default:return null}const o=JSON.parse(r);return Object.values(o.keys)[0]}finally{t.free()}}async bootstrapCrossSigning(e){await this.crossSigningIdentity.bootstrapCrossSigning(e)}async isSecretStorageReady(){const e=["m.cross_signing.master","m.cross_signing.user_signing","m.cross_signing.self_signing"];return await this.backupManager.getActiveBackupVersion()!=null&&e.push("m.megolm_backup.v1"),ke(this.secretStorage,e)}async bootstrapSecretStorage({createSecretStorageKey:e,setupNewSecretStorage:t,setupNewKeyBackup:s}={}){const i=t||!await this.secretStorageHasAESKey();if(i){if(!e)throw new Error("unable to create a new secret storage key, createSecretStorageKey is not set");this.logger.info("bootstrapSecretStorage: creating new secret storage key");const a=await e();if(!a)throw new Error("createSecretStorageKey() callback did not return a secret storage key");await this.addSecretStorageKeyToSecretStorage(a)}const r=await this.olmMachine.crossSigningStatus();if(r.hasMaster&&r.hasSelfSigning&&r.hasUserSigning&&(i||!await se(this.secretStorage))){this.logger.info("bootstrapSecretStorage: cross-signing keys not yet exported; doing so now.");const a=await this.olmMachine.exportCrossSigningKeys();if(!a.masterKey)throw new Error("missing master key in cross signing private keys");if(!a.userSigningKey)throw new Error("missing user signing key in cross signing private keys");if(!a.self_signing_key)throw new Error("missing self signing key in cross signing private keys");await this.secretStorage.store("m.cross_signing.master",a.masterKey),await this.secretStorage.store("m.cross_signing.user_signing",a.userSigningKey),await this.secretStorage.store("m.cross_signing.self_signing",a.self_signing_key)}s&&await this.resetKeyBackup()}async addSecretStorageKeyToSecretStorage(e){var s,i,r,o;const t=await this.secretStorage.addKey(Z,{passphrase:(s=e.keyInfo)==null?void 0:s.passphrase,name:(i=e.keyInfo)==null?void 0:i.name,key:e.privateKey});await this.secretStorage.setDefaultKeyId(t.keyId),(o=(r=this.cryptoCallbacks).cacheSecretStorageKey)==null||o.call(r,t.keyId,t.keyInfo,e.privateKey)}async secretStorageHasAESKey(){const e=await this.secretStorage.getKey();if(!e)return!1;const[,t]=e;return t.algorithm===Z}async getCrossSigningStatus(){const e=await this.getOlmMachineOrThrow().getIdentity(new n.UserId(this.userId)),t=!!(e!=null&&e.masterKey)&&!!(e!=null&&e.selfSigningKey)&&!!(e!=null&&e.userSigningKey);e==null||e.free();const s=await se(this.secretStorage),i=await this.getOlmMachineOrThrow().crossSigningStatus();return{publicKeysOnDevice:t,privateKeysInSecretStorage:s,privateKeysCachedLocally:{masterKey:!!(i!=null&&i.hasMaster),userSigningKey:!!(i!=null&&i.hasUserSigning),selfSigningKey:!!(i!=null&&i.hasSelfSigning)}}}async createRecoveryKeyFromPassphrase(e){if(e){const t=X(32),s=await De(e,t,this.RECOVERY_KEY_DERIVATION_ITERATIONS);return{keyInfo:{passphrase:{algorithm:"m.pbkdf2",iterations:this.RECOVERY_KEY_DERIVATION_ITERATIONS,salt:t}},privateKey:s,encodedPrivateKey:ee(s)}}else{const t=new Uint8Array(32);return globalThis.crypto.getRandomValues(t),{privateKey:t,encodedPrivateKey:ee(t)}}}async getEncryptionInfoForEvent(e){return this.eventDecryptor.getEncryptionInfoForEvent(e)}getVerificationRequestsToDeviceInProgress(e){return this.olmMachine.getVerificationRequests(new n.UserId(e)).filter(s=>s.roomId===void 0).map(s=>new M(this.olmMachine,s,this.outgoingRequestProcessor,this._supportedVerificationMethods))}findVerificationRequestDMInProgress(e,t){if(!t)throw new Error("missing userId");const i=this.olmMachine.getVerificationRequests(new n.UserId(t)).find(r=>{var o;return((o=r.roomId)==null?void 0:o.toString())===e});if(i)return new M(this.olmMachine,i,this.outgoingRequestProcessor,this._supportedVerificationMethods)}async requestVerificationDM(e,t){const s=await this.olmMachine.getIdentity(new n.UserId(e));if(!s)throw new Error(`unknown userId ${e}`);try{const i=this._supportedVerificationMethods.map(u=>$(u)),r=await s.verificationRequestContent(i),o=await this.sendVerificationRequestContent(t,r),a=await s.requestVerification(new n.RoomId(t),new n.EventId(o),i);return new M(this.olmMachine,a,this.outgoingRequestProcessor,this._supportedVerificationMethods)}finally{s.free()}}async sendVerificationRequestContent(e,t){const s=X(32),{event_id:i}=await this.http.authedRequest(f.Put,`/_matrix/client/v3/rooms/${encodeURIComponent(e)}/send/m.room.message/${encodeURIComponent(s)}`,void 0,t,{prefix:""});return i}setSupportedVerificationMethods(e){this._supportedVerificationMethods=e??ue}async requestOwnUserVerification(){const e=await this.olmMachine.getIdentity(new n.UserId(this.userId));if(e===void 0)throw new Error("cannot request verification for this device when there is no existing cross-signing key");try{const[t,s]=await e.requestVerification(this._supportedVerificationMethods.map($));return await this.outgoingRequestProcessor.makeOutgoingRequest(s),new M(this.olmMachine,t,this.outgoingRequestProcessor,this._supportedVerificationMethods)}finally{e.free()}}async requestDeviceVerification(e,t){const s=await this.olmMachine.getDevice(new n.UserId(e),new n.DeviceId(t));if(!s)throw new Error("Not a known device");try{const[i,r]=s.requestVerification(this._supportedVerificationMethods.map($));return await this.outgoingRequestProcessor.makeOutgoingRequest(r),new M(this.olmMachine,i,this.outgoingRequestProcessor,this._supportedVerificationMethods)}finally{s.free()}}async getSessionBackupPrivateKey(){const e=await this.olmMachine.getBackupKeys();return e.decryptionKey?Buffer.from(e.decryptionKey.toBase64(),"base64"):null}async storeSessionBackupPrivateKey(e,t){const s=j(e);if(!t)throw new Error("storeSessionBackupPrivateKey: version is required");await this.backupManager.saveBackupDecryptionKey(n.BackupDecryptionKey.fromBase64(s),t)}async loadSessionBackupPrivateKeyFromSecretStorage(){const e=await this.secretStorage.get("m.megolm_backup.v1");if(!e)throw new Error("loadSessionBackupPrivateKeyFromSecretStorage: missing decryption key in secret storage");const t=await this.backupManager.getServerBackupInfo();if(!t||!t.version)throw new Error("loadSessionBackupPrivateKeyFromSecretStorage: unable to get backup version");const s=n.BackupDecryptionKey.fromBase64(e);if(!oe(s,t))throw new Error("loadSessionBackupPrivateKeyFromSecretStorage: decryption key does not match backup info");await this.backupManager.saveBackupDecryptionKey(s,t.version)}async getActiveSessionBackupVersion(){return await this.backupManager.getActiveBackupVersion()}async getKeyBackupInfo(){return await this.backupManager.getServerBackupInfo()||null}async isKeyBackupTrusted(e){return await this.backupManager.isKeyBackupTrusted(e)}async checkKeyBackupAndEnable(){return await this.backupManager.checkKeyBackupAndEnable(!0)}async deleteKeyBackupVersion(e){await this.backupManager.deleteKeyBackupVersion(e)}async resetKeyBackup(){const e=await this.backupManager.setupKeyBackup(t=>this.signObject(t));await this.secretStorageHasAESKey()&&await this.secretStorage.store("m.megolm_backup.v1",e.decryptionKey.toBase64()),this.checkKeyBackupAndEnable()}async signObject(e){const t=new Map(Object.entries(e.signatures||{})),s=e.unsigned;delete e.signatures,delete e.unsigned;const i=t.get(this.userId)||{},r=_e.stringify(e),o=await this.olmMachine.sign(r),a=JSON.parse(o.asJSON());t.set(this.userId,{...i,...a[this.userId]}),s!==void 0&&(e.unsigned=s),e.signatures=Object.fromEntries(t.entries())}async restoreKeyBackupWithPassphrase(e,t){const s=await this.backupManager.getServerBackupInfo();if(!(s!=null&&s.version))throw new Error("No backup info available");const i=await Be(s.auth_data,e);return await this.storeSessionBackupPrivateKey(i,s.version),this.restoreKeyBackup(t)}async restoreKeyBackup(e){var u;const t=await this.olmMachine.getBackupKeys(),{decryptionKey:s,backupVersion:i}=t;if(!s||!i)throw new Error("No decryption key found in crypto store");const r=de(s.toBase64()),o=await this.backupManager.requestKeyBackupVersion(i);if(!o)throw new Error(`Backup version to restore ${i} not found on server`);const a=await this.getBackupDecryptor(o,r);try{return(u=e==null?void 0:e.progressCallback)==null||u.call(e,{stage:"fetch"}),await this.backupManager.restoreKeyBackup(i,a,e)}finally{a.free()}}async isDehydrationSupported(){return await this.dehydratedDeviceManager.isSupported()}async startDehydration(e){if(!await this.isCrossSigningReady()||!await this.isSecretStorageReady())throw new Error("Device dehydration requires cross-signing and secret storage to be set up");return await this.dehydratedDeviceManager.start(e)}async importSecretsBundle(e){const t=n.SecretsBundle.from_json(e);await this.getOlmMachineOrThrow().importSecretsBundle(t)}async exportSecretsBundle(){const e=await this.getOlmMachineOrThrow().exportSecretsBundle(),t=e.to_json();return e.free(),t}async encryptToDeviceMessages(e,t,s){const i=new ge(this.logger,"encryptToDeviceMessages"),r=new Set(t.map(({userId:a})=>a));await this.keyClaimManager.ensureSessionsForUsers(i,Array.from(r).map(a=>new n.UserId(a)));const o={batch:[],eventType:S.RoomMessageEncrypted};return await Promise.all(t.map(async({userId:a,deviceId:u})=>{const h=await this.olmMachine.getDevice(new n.UserId(a),new n.DeviceId(u));if(h){const d=JSON.parse(await h.encryptToDeviceEvent(e,s));o.batch.push({deviceId:u,userId:a,payload:d})}else this.logger.warn(`encryptToDeviceMessages: unknown device ${a}:${u}`)})),o}async receiveSyncChanges({events:e,oneTimeKeysCounts:t=new Map,unusedFallbackKeys:s,devices:i=new n.DeviceLists}){const r=await K(g,"receiveSyncChanges",async()=>await this.olmMachine.receiveSyncChanges(e?JSON.stringify(e):"[]",i,t,s));return JSON.parse(r)}async preprocessToDeviceMessages(e){const t=await this.receiveSyncChanges({events:e});for(const s of t)if(s.type===S.KeyVerificationRequest){const i=s.sender,r=s.content.transaction_id;r&&i&&this.onIncomingKeyVerificationRequest(i,r)}return t}async processKeyCounts(e,t){const s=e&&new Map(Object.entries(e)),i=t&&new Set(t);(s!==void 0||i!==void 0)&&await this.receiveSyncChanges({oneTimeKeysCounts:s,unusedFallbackKeys:i})}async processDeviceLists(e){var s,i;const t=new n.DeviceLists((s=e.changed)==null?void 0:s.map(r=>new n.UserId(r)),(i=e.left)==null?void 0:i.map(r=>new n.UserId(r)));await this.receiveSyncChanges({devices:t})}async onCryptoEvent(e,t){const s=t.getContent(),i=new n.RoomSettings;if(s.algorithm==="m.megolm.v1.aes-sha2")i.algorithm=n.EncryptionAlgorithm.MegolmV1AesSha2;else{this.logger.warn(`Room ${e.roomId}: ignoring crypto event with invalid algorithm ${s.algorithm}`);return}try{i.sessionRotationPeriodMs=s.rotation_period_ms,i.sessionRotationPeriodMessages=s.rotation_period_msgs,await this.olmMachine.setRoomSettings(new n.RoomId(e.roomId),i)}catch(o){this.logger.warn(`Room ${e.roomId}: ignoring crypto event which caused error: ${o}`);return}const r=this.roomEncryptors[e.roomId];r?r.onCryptoEvent(s):this.roomEncryptors[e.roomId]=new Oe(this.olmMachine,this.keyClaimManager,this.outgoingRequestsManager,e,s)}onSyncCompleted(e){this.outgoingRequestsManager.doProcessOutgoingRequests().catch(t=>{this.logger.warn("onSyncCompleted: Error processing outgoing requests",t)})}onIncomingKeyVerificationRequest(e,t){const s=this.olmMachine.getVerificationRequest(new n.UserId(e),t);s?this.emit(y.VerificationRequestReceived,new M(this.olmMachine,s,this.outgoingRequestProcessor,this._supportedVerificationMethods)):this.logger.info(`Ignoring just-received verification request ${t} which did not start a rust-side verification`)}onRoomMembership(e,t,s){const i=this.roomEncryptors[e.getRoomId()];i&&i.onRoomMembership(t)}async onRoomKeysUpdated(e){for(const t of e)this.onRoomKeyUpdated(t);this.backupManager.maybeUploadKey()}onRoomKeyUpdated(e){if(this.stopped)return;this.logger.debug(`Got update for session ${e.sessionId} from sender ${e.senderKey.toBase64()} in ${e.roomId.toString()}`);const t=this.eventDecryptor.getEventsPendingRoomKey(e.roomId.toString(),e.sessionId);if(t.length!==0){this.logger.debug("Retrying decryption on events:",t.map(s=>`${s.getId()}`));for(const s of t)s.attemptDecryption(this,{isRetry:!0}).catch(i=>{this.logger.info(`Still unable to decrypt event ${s.getId()} after receiving key`)})}}async onRoomKeysWithheld(e){for(const t of e){this.logger.debug(`Got withheld message for session ${t.sessionId} in ${t.roomId.toString()}`);const s=this.eventDecryptor.getEventsPendingRoomKey(t.roomId.toString(),t.sessionId);if(s.length===0)return;this.logger.debug("Retrying decryption on events:",s.map(i=>`${i.getId()}`));for(const i of s)i.attemptDecryption(this,{isRetry:!0}).catch(r=>{})}}async onUserIdentityUpdated(e){const t=await this.getUserVerificationStatus(e.toString());this.emit(y.UserTrustStatusChanged,e.toString(),t),e.toString()===this.userId&&(this.emit(y.KeysChanged,{}),await this.checkKeyBackupAndEnable())}async onDevicesUpdated(e){this.emit(y.WillUpdateDevices,e,!1),this.emit(y.DevicesUpdated,e,!1)}async handleSecretReceived(e,t){return this.logger.debug(`onReceiveSecret: Received secret ${e}`),e==="m.megolm_backup.v1"?await this.backupManager.handleBackupSecretReceived(t):!1}async checkSecrets(e){const t=await this.olmMachine.getSecretsFromInbox(e);for(const s of t)if(await this.handleSecretReceived(e,s))break;await this.olmMachine.deleteSecretsFromInbox(e)}async onLiveEventFromSync(e){if(e.isState()||e.getUnsigned().transaction_id)return;const t=async s=>{Fe(e)&&await this.onKeyVerificationEvent(s)};if(e.isDecryptionFailure()||e.isEncrypted()){const i=setTimeout(()=>e.off(H.Decrypted,r),3e5),r=(o,a)=>{a||(clearTimeout(i),e.off(H.Decrypted,r),t(o))};e.on(H.Decrypted,r)}else await t(e)}async onKeyVerificationEvent(e){const t=e.getRoomId();if(!t)throw new Error("missing roomId in the event");this.logger.debug(`Incoming verification event ${e.getId()} type ${e.getType()} from ${e.getSender()}`),await this.olmMachine.receiveVerificationEvent(JSON.stringify({event_id:e.getId(),type:e.getType(),sender:e.getSender(),state_key:e.getStateKey(),content:e.getContent(),origin_server_ts:e.getTs()}),new n.RoomId(t)),e.getType()===S.RoomMessage&&e.getContent().msgtype===me.KeyVerificationRequest&&this.onIncomingKeyVerificationRequest(e.getSender(),e.getId()),this.outgoingRequestsManager.doProcessOutgoingRequests().catch(s=>{this.logger.warn("onKeyVerificationRequest: Error processing outgoing requests",s)})}async getOwnIdentity(){return await this.olmMachine.getIdentity(new n.UserId(this.userId))}}class je{constructor(e,t,s){this.logger=e,this.olmMachine=t,this.perSessionBackupDownloader=s,this.eventsPendingKey=new te(()=>new te(()=>new Set))}async attemptEventDecryption(e,t){this.addEventToPendingList(e);let s;switch(t.kind){case F.AllDevicesIsolationMode:s=n.TrustRequirement.Untrusted;break;case F.OnlySignedDevicesIsolationMode:s=n.TrustRequirement.CrossSignedOrLegacy;break}try{const i=await this.olmMachine.decryptRoomEvent(he(e),new n.RoomId(e.getRoomId()),new n.DecryptionSettings(s));return this.removeEventFromPendingList(e),{clearEvent:JSON.parse(i.event),claimedEd25519Key:i.senderClaimedEd25519Key,senderCurve25519Key:i.senderCurve25519Key,forwardingCurve25519KeyChain:i.forwardingCurve25519KeyChain}}catch(i){if(i instanceof n.MegolmDecryptionError)this.onMegolmDecryptionError(e,i,await this.perSessionBackupDownloader.getServerBackupInfo());else throw new v(k.UNKNOWN_ERROR,"Unknown error")}}onMegolmDecryptionError(e,t,s){const i=e.getWireContent(),r={sender_key:i.sender_key,session_id:i.session_id};if(t.code===n.DecryptionErrorCode.MissingRoomKey||t.code===n.DecryptionErrorCode.UnknownMessageIndex){this.perSessionBackupDownloader.onDecryptionKeyMissingError(e.getRoomId(),i.session_id);const o=e.getMembershipAtEvent();if(o&&o!==x.Join&&o!==x.Invite)throw new v(k.HISTORICAL_MESSAGE_USER_NOT_JOINED,"This message was sent when we were not a member of the room.",r);if(e.getTs()<=this.olmMachine.deviceCreationTimeMs)throw s===null?new v(k.HISTORICAL_MESSAGE_NO_KEY_BACKUP,"This message was sent before this device logged in, and there is no key backup on the server.",r):this.perSessionBackupDownloader.isKeyBackupDownloadConfigured()?new v(k.HISTORICAL_MESSAGE_WORKING_BACKUP,"This message was sent before this device logged in. Key backup is working, but we still do not (yet) have the key.",r):new v(k.HISTORICAL_MESSAGE_BACKUP_UNCONFIGURED,"This message was sent before this device logged in, and key backup is not working.",r)}if(t.maybe_withheld){const o=t.maybe_withheld==="The sender has disabled encrypting to unverified devices."?k.MEGOLM_KEY_WITHHELD_FOR_UNVERIFIED_DEVICE:k.MEGOLM_KEY_WITHHELD;throw new v(o,t.maybe_withheld,r)}switch(t.code){case n.DecryptionErrorCode.MissingRoomKey:throw new v(k.MEGOLM_UNKNOWN_INBOUND_SESSION_ID,"The sender's device has not sent us the keys for this message.",r);case n.DecryptionErrorCode.UnknownMessageIndex:throw new v(k.OLM_UNKNOWN_MESSAGE_INDEX,"The sender's device has not sent us the keys for this message at this index.",r);case n.DecryptionErrorCode.SenderIdentityPreviouslyVerified:throw this.removeEventFromPendingList(e),new v(k.SENDER_IDENTITY_PREVIOUSLY_VERIFIED,"The sender identity is unverified, but was previously verified.");case n.DecryptionErrorCode.UnknownSenderDevice:throw this.removeEventFromPendingList(e),new v(k.UNKNOWN_SENDER_DEVICE,"The sender device is not known.");case n.DecryptionErrorCode.UnsignedSenderDevice:throw this.removeEventFromPendingList(e),new v(k.UNSIGNED_SENDER_DEVICE,"The sender identity is not cross-signed.");default:throw new v(k.UNKNOWN_ERROR,t.description,r)}}async getEncryptionInfoForEvent(e){if(!e.getClearContent()||e.isDecryptionFailure())return null;if(e.status!==null)return{shieldColour:A.NONE,shieldReason:null};const t=await this.olmMachine.getRoomEventEncryptionInfo(he(e),new n.RoomId(e.getRoomId()));return Ye(this.logger,t)}getEventsPendingRoomKey(e,t){const s=this.eventsPendingKey.get(e);if(!s)return[];const i=s.get(t);return i?[...i]:[]}addEventToPendingList(e){const t=e.getRoomId();if(!t)return;this.eventsPendingKey.getOrCreate(t).getOrCreate(e.getWireContent().session_id).add(e)}removeEventFromPendingList(e){const t=e.getRoomId();if(!t)return;const s=this.eventsPendingKey.getOrCreate(t);if(!s)return;const i=s.get(e.getWireContent().session_id);i&&(i.delete(e),i.size===0&&(s.delete(e.getWireContent().session_id),s.size===0&&this.eventsPendingKey.delete(t)))}}function he(c){return JSON.stringify({event_id:c.getId(),type:c.getWireType(),sender:c.getSender(),state_key:c.getStateKey(),content:c.getWireContent(),origin_server_ts:c.getTs()})}function Ye(c,e){if(e===void 0)return null;const t=e.shieldState(!1);let s;switch(t.color){case n.ShieldColor.Grey:s=A.GREY;break;case n.ShieldColor.None:s=A.NONE;break;default:s=A.RED}let i;return t.message===void 0?i=null:t.message==="Encrypted by an unverified user."?i=D.UNVERIFIED_IDENTITY:t.message==="Encrypted by a device not verified by its owner."?i=D.UNSIGNED_DEVICE:t.message==="The authenticity of this encrypted message can't be guaranteed on this device."?i=D.AUTHENTICITY_NOT_GUARANTEED:t.message==="Encrypted by an unknown or deleted device."?i=D.UNKNOWN_DEVICE:(c.warn(`Unknown shield state message '${t.message}'`),i=D.UNKNOWN),{shieldColour:s,shieldReason:i}}async function ze(c){var l;const{logger:e,legacyStore:t}=c;if(await n.initAsync(),new n.Tracing(n.LoggerLevel.Debug).turnOn(),!await t.containsData())return;await t.startup();let s=null;if(await t.doTxn("readonly",[O.STORE_ACCOUNT],p=>{t.getAccount(p,w=>{s=w})}),!s){e.debug("Legacy crypto store is not set up (no account found). Not migrating.");return}let i=await t.getMigrationState();if(i>=R.MEGOLM_SESSIONS_MIGRATED)return;const r=await Xe(e,t),o=await et(e,t),a=1+r+o;e.info(`Migrating data from legacy crypto store. ${r} olm sessions and ${o} megolm sessions to migrate.`);let u=0;function h(p){var w;u+=p,(w=c.legacyMigrationProgressListener)==null||w.call(c,u,a)}h(0);const d=new TextEncoder().encode(c.legacyPickleKey);i===R.NOT_STARTED&&(e.info("Migrating data from legacy crypto store. Step 1: base data"),await Ze(c.http,c.userId,c.deviceId,t,d,c.storeHandle,e),i=R.INITIAL_DATA_MIGRATED,await t.setMigrationState(i)),h(1),i===R.INITIAL_DATA_MIGRATED&&(e.info(`Migrating data from legacy crypto store. Step 2: olm sessions (${r} sessions to migrate).`),await tt(e,t,d,c.storeHandle,h),i=R.OLM_SESSIONS_MIGRATED,await t.setMigrationState(i)),i===R.OLM_SESSIONS_MIGRATED&&(e.info(`Migrating data from legacy crypto store. Step 3: megolm sessions (${o} sessions to migrate).`),await st(e,t,d,c.storeHandle,h),i=R.MEGOLM_SESSIONS_MIGRATED,await t.setMigrationState(i)),(l=c.legacyMigrationProgressListener)==null||l.call(c,-1,-1),e.info("Migration from legacy crypto store complete")}async function Ze(c,e,t,s,i,r,o){var h;const a=new n.BaseMigrationData;a.userId=new n.UserId(e),a.deviceId=new n.DeviceId(t),await s.doTxn("readonly",[O.STORE_ACCOUNT],d=>s.getAccount(d,l=>{a.pickledAccount=l??""}));const u=await V(s,i,"m.megolm_backup.v1");if(u){let d=!1,l=null;for(;!d;)try{l=await Re(c),d=!0}catch(p){o.info("Failed to get backup version during migration, retrying in 2 seconds",p),await I(2e3)}if(l&&l.algorithm=="m.megolm_backup.v1.curve25519-aes-sha2")try{const p=n.BackupDecryptionKey.fromBase64(u),w=(h=l.auth_data)==null?void 0:h.public_key;p.megolmV1PublicKey.publicKeyBase64==w?(a.backupVersion=l.version,a.backupRecoveryKey=u):o.debug("The backup key to migrate does not match the active backup version",`Cached pub key: ${p.megolmV1PublicKey.publicKeyBase64}`,`Active pub key: ${w}`)}catch(p){o.warn("Failed to check if the backup key to migrate matches the active backup version",p)}}a.privateCrossSigningMasterKey=await V(s,i,"master"),a.privateCrossSigningSelfSigningKey=await V(s,i,"self_signing"),a.privateCrossSigningUserSigningKey=await V(s,i,"user_signing"),await n.Migration.migrateBaseData(a,i,r)}async function Xe(c,e){c.debug("Counting olm sessions to be migrated");let t;return await e.doTxn("readonly",[O.STORE_SESSIONS],s=>e.countEndToEndSessions(s,i=>t=i)),t}async function et(c,e){return c.debug("Counting megolm sessions to be migrated"),await e.countEndToEndInboundGroupSessions()}async function tt(c,e,t,s,i){for(;;){const r=await e.getEndToEndSessionsBatch();if(r===null)return;c.debug(`Migrating batch of ${r.length} olm sessions`);const o=[];for(const a of r){const u=new n.PickledSession;u.senderKey=a.deviceKey,u.pickle=a.session,u.lastUseTime=u.creationTime=new Date(a.lastReceivedMessageTs),o.push(u)}await n.Migration.migrateOlmSessions(o,t,s),await e.deleteEndToEndSessionsBatch(r),i(r.length)}}async function st(c,e,t,s,i){var r;for(;;){const o=await e.getEndToEndInboundGroupSessionsBatch();if(o===null)return;c.debug(`Migrating batch of ${o.length} megolm sessions`);const a=[];for(const u of o){const h=u.sessionData,d=new n.PickledInboundGroupSession;d.pickle=h.session,d.roomId=new n.RoomId(h.room_id),d.senderKey=u.senderKey,d.senderSigningKey=(r=h.keysClaimed)==null?void 0:r.ed25519,d.backedUp=!u.needsBackup,d.imported=h.untrusted===!0,a.push(d)}await n.Migration.migrateMegolmSessions(a,t,s),await e.deleteEndToEndInboundGroupSessionsBatch(o),i(o.length)}}async function it({logger:c,legacyStore:e,olmMachine:t}){if(!await e.containsData()||await e.getMigrationState()>=R.ROOM_SETTINGS_MIGRATED)return;let i={};await e.doTxn("readwrite",[O.STORE_ROOMS],r=>{e.getEndToEndRooms(r,o=>{i=o})}),c.debug(`Migrating ${Object.keys(i).length} sets of room settings`);for(const[r,o]of Object.entries(i))try{const a=new n.RoomSettings;if(o.algorithm!=="m.megolm.v1.aes-sha2"){c.warn(`Room ${r}: ignoring room with invalid algorithm ${o.algorithm}`);continue}a.algorithm=n.EncryptionAlgorithm.MegolmV1AesSha2,a.sessionRotationPeriodMs=o.rotation_period_ms,a.sessionRotationPeriodMessages=o.rotation_period_msgs,await t.setRoomSettings(new n.RoomId(r),a)}catch(a){c.warn(`Room ${r}: ignoring settings ${JSON.stringify(o)} which caused error ${a}`)}c.debug("Completed room settings migration"),await e.setMigrationState(R.ROOM_SETTINGS_MIGRATED)}async function V(c,e,t){const s=await new Promise(i=>{c.doTxn("readonly",[O.STORE_ACCOUNT],r=>{c.getSecretStorePrivateKey(r,i,t)})});return s&&s.ciphertext&&s.iv&&s.mac?await qe(s,e,t):s instanceof Uint8Array?j(s):void 0}async function rt(c){const{legacyCryptoStore:e,rustCrypto:t,logger:s}=c,i=await t.getOwnIdentity();if(!i||i.isVerified())return;const r=await nt(e);if(!r)return;const o=JSON.parse(i.masterKey);if(!o.keys||Object.keys(o.keys).length===0){s.error("Post Migration | Unexpected error: no master key in the rust session.");return}const a=Object.values(o.keys)[0];a&&a==r&&(s.info(`Post Migration: Migrating legacy trusted MSK: ${r} to locally verified.`),await i.verify())}async function nt(c){let e=null;return await c.doTxn("readonly","account",t=>{c.getCrossSigningKeys(t,s=>{const i=s==null?void 0:s.master;i&&Object.keys(i.keys).length!=0&&(e=Object.values(i.keys)[0])})}),e}async function ut(c){const{logger:e}=c;e.debug("Initialising Rust crypto-sdk WASM artifact"),await n.initAsync(),new n.Tracing(n.LoggerLevel.Debug).turnOn(),e.debug("Opening Rust CryptoStore");let t;c.storePrefix?c.storeKey?t=await n.StoreHandle.openWithKey(c.storePrefix,c.storeKey):t=await n.StoreHandle.open(c.storePrefix,c.storePassphrase):t=await n.StoreHandle.open(),c.legacyCryptoStore&&await ze({legacyStore:c.legacyCryptoStore,storeHandle:t,...c});const s=await ot(e,c.http,c.userId,c.deviceId,c.secretStorage,c.cryptoCallbacks,t,c.legacyCryptoStore);return t.free(),e.debug("Completed rust crypto-sdk setup"),s}async function ot(c,e,t,s,i,r,o,a){c.debug("Init OlmMachine");const u=await n.OlmMachine.initFromStore(new n.UserId(t),new n.DeviceId(s),o);a&&await it({logger:c,legacyStore:a,olmMachine:u}),u.roomKeyRequestsEnabled=!1;const h=new Qe(c,u,e,t,s,i,r);if(await u.registerRoomKeyUpdatedCallback(d=>h.onRoomKeysUpdated(d)),await u.registerRoomKeysWithheldCallback(d=>h.onRoomKeysWithheld(d)),await u.registerUserIdentityUpdatedCallback(d=>h.onUserIdentityUpdated(d)),await u.registerDevicesUpdatedCallback(d=>h.onDevicesUpdated(d)),h.checkSecrets("m.megolm_backup.v1"),await u.registerReceiveSecretCallback((d,l)=>h.checkSecrets(d)),await u.outgoingRequests(),a&&await a.containsData()&&await a.getMigrationState()<R.INITIAL_OWN_KEY_QUERY_DONE){c.debug("Performing initial key query after migration");let l=!1;for(;!l;)try{await h.userHasCrossSigningKeys(t),l=!0}catch(p){c.error("Failed to check for cross-signing keys after migration, retrying",p)}await rt({legacyCryptoStore:a,rustCrypto:h,logger:c}),await a.setMigrationState(R.INITIAL_OWN_KEY_QUERY_DONE)}return h}export{ut as initRustCrypto};
//# sourceMappingURL=index-BnUge9vt.js.map
